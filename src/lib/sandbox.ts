/**
 * Ceptra AI — Code Execution Sandbox
 *
 * Safely executes code on the server. This is the foundation for ALL file
 * generation tools (docx, pptx, xlsx, pdf are all generated by running code).
 *
 * Supported: Python, JavaScript, TypeScript, Bash
 * Safety: Runs in child_process with timeout and resource limits
 */

import { exec } from 'child_process';
import { writeFile, mkdir, readdir, stat } from 'fs/promises';
import { join } from 'path';
import { v4 as uuidv4 } from 'uuid';
import { CodeResult, GeneratedFile } from './tool-engine';

const WORKSPACE_BASE = '/tmp/ceptra-sandbox';
const TIMEOUT_MS = 30000; // 30 seconds max
const MAX_OUTPUT = 10000; // 10KB max output

export interface SandboxResult {
  code: CodeResult;
  files: GeneratedFile[];
}

// ── Execute Code ──
export async function executeCode(
  code: string,
  language: string,
  filename?: string
): Promise<SandboxResult> {
  const sandboxId = uuidv4().slice(0, 8);
  const workDir = join(WORKSPACE_BASE, sandboxId);
  await mkdir(workDir, { recursive: true });

  const ext = getExtension(language);
  const file = filename || `main${ext}`;
  const filePath = join(workDir, file);
  const outputDir = join(workDir, 'output');
  await mkdir(outputDir, { recursive: true });

  // Write code to file
  await writeFile(filePath, code, 'utf-8');

  // Build command
  const cmd = buildCommand(language, filePath, workDir);

  // Execute with timeout
  const startTime = Date.now();

  return new Promise((resolve) => {
    const process = exec(cmd, {
      cwd: workDir,
      timeout: TIMEOUT_MS,
      maxBuffer: 1024 * 1024, // 1MB
      env: {
        ...globalThis.process.env,
        OUTPUT_DIR: outputDir,
        HOME: workDir,
        PYTHONDONTWRITEBYTECODE: '1',
      },
    }, async (error, stdout, stderr) => {
      const duration = Date.now() - startTime;
      const output = (stdout || '').slice(0, MAX_OUTPUT);
      const errorOutput = (stderr || '').slice(0, MAX_OUTPUT);
      const exitCode = error ? (error as any).code || 1 : 0;

      // Collect any generated files
      const files = await collectFiles(outputDir, sandboxId);

      resolve({
        code: {
          language,
          code,
          output: output + (errorOutput ? `\nSTDERR:\n${errorOutput}` : ''),
          exitCode,
          duration,
        },
        files,
      });
    });
  });
}

// ── Generate Document (runs code that creates a file) ──
export async function generateFile(
  generatorCode: string,
  language: string = 'javascript',
  outputFilename: string
): Promise<SandboxResult> {
  // Inject the output path into the code
  const code = generatorCode.replace(
    /OUTPUT_PATH/g,
    `"/tmp/ceptra-sandbox/output/${outputFilename}"`
  );

  return executeCode(code, language, `generator${getExtension(language)}`);
}

// ── Helpers ──

function getExtension(language: string): string {
  const map: Record<string, string> = {
    python: '.py', py: '.py',
    javascript: '.js', js: '.js',
    typescript: '.ts', ts: '.ts',
    bash: '.sh', sh: '.sh',
    html: '.html',
    css: '.css',
    sql: '.sql',
    json: '.json',
  };
  return map[language.toLowerCase()] || '.txt';
}

function buildCommand(language: string, filePath: string, workDir: string): string {
  const lang = language.toLowerCase();

  switch (lang) {
    case 'python':
    case 'py':
      return `python3 "${filePath}"`;

    case 'javascript':
    case 'js':
      return `node "${filePath}"`;

    case 'typescript':
    case 'ts':
      return `npx tsx "${filePath}"`;

    case 'bash':
    case 'sh':
      return `bash "${filePath}"`;

    default:
      return `node "${filePath}"`;
  }
}

async function collectFiles(outputDir: string, sandboxId: string): Promise<GeneratedFile[]> {
  const files: GeneratedFile[] = [];

  try {
    const entries = await readdir(outputDir);

    for (const entry of entries) {
      const fullPath = join(outputDir, entry);
      const stats = await stat(fullPath);

      if (stats.isFile()) {
        files.push({
          name: entry,
          path: fullPath,
          size: stats.size,
          mimeType: getMimeType(entry),
          downloadUrl: `/api/files/${sandboxId}/${entry}`,
        });
      }
    }
  } catch {
    // Output dir may not exist or be empty
  }

  return files;
}

function getMimeType(filename: string): string {
  const ext = filename.split('.').pop()?.toLowerCase();
  const map: Record<string, string> = {
    pdf: 'application/pdf',
    docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    pptx: 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    png: 'image/png',
    jpg: 'image/jpeg',
    jpeg: 'image/jpeg',
    svg: 'image/svg+xml',
    html: 'text/html',
    css: 'text/css',
    js: 'application/javascript',
    ts: 'text/typescript',
    json: 'application/json',
    txt: 'text/plain',
    md: 'text/markdown',
    csv: 'text/csv',
  };
  return map[ext || ''] || 'application/octet-stream';
}
